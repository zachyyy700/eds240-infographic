---
title: "EDS 240: Final Project - Exploratory Analysis"
author: "Zach Loo"
execute:
    warning: false
---

[Data Source](https://www.kaggle.com/datasets/takamotoki/jra-horse-racing-dataset/data)

# Begin EDA 

```{r}
#| warning: false
#| message: false
# Load packages
library(tidyverse)
library(gghighlight)
library(scales)
library(patchwork)
```

```{r}
#| warning: false
# Load data, parsing certain columns as character
jra_results <- read_csv(here::here('data', '19860105-20210731_race_result.csv'),
col_types = cols(レース馬番ID = 'c', レースID = 'c', タイム = 'c')) |> 
    # Omit レース記号 columns
    select(-starts_with("レース記号"))

# jra_odds <- read_csv(here::here("data", "19860105-20210731_odds.csv"))
# jra_laptime <- read_csv(here::here("data", "19860105-20210731_laptime.csv"),
# col_types = cols(.default = 'c'))
# jra_cornerpassing <- read_csv(here::here("data", "20020615-20210731_corner_passing_order.csv"))
colors <- c("#A4252A", "#E74A22", "#F4BA1F", "#F8F360", "#4392CE", "#F9D1C5")
```

## Initial Wrangling

A language barrier was anticipated with this dataset. For ease of use, the dataset's columns can be translated.

**Additionally, plot labels like axis and legend text do not show up in the rendered quarto doc (but they do in the editor) since they're in Japanese. Only some plots I've created have been manually translated so they show up on the plot in English. These are the ones I've started to polish and considering for the final infographic.**

```{r}
# Create dataset copy
jra_results_eng <- jra_results

# Translate df columns
colnames(jra_results_eng) <- c("race_pp_id", "race_id", "race_date", "race_meeting_number", "racecourse_code", "racecourse_name", "nth_raceday", "race_prereq", "race_number", "graded_race_nth_time", "race_name", "listed_graded_race", "steeplechase", "turf_dirt", "turf_dirt2_steeplechase", "left_right_straight", "inside_outside", "distance_m", "weather", "track_condition1", "track_condition2_steeplechase", "post_time", "final_position", "final_position_notes", "bracket_number", "horse_number", "horse_name", "horse_sex", "horse_age", "jockey_weight", "jockey_name", "finish_time", "margin", "corner1_position", "corner2_position", "corner3_position", "corner4_position", "final_600m_time", "win_odds_100Y", "popular_rank", "horse_weight", "horse_weight_diff", "east_west_foreign", "horse_trainer", "horse_owner", "prize_money_10kY")

```

```{r}
# Add year and month columns
jra_results_eng  <- jra_results_eng |> 
    mutate(year = year(race_date), month = month(race_date))

# Convert character to duration
jra_results_eng$finish_time <- ms(jra_results_eng$finish_time)
jra_results_eng$finish_time <- as.duration(jra_results_eng$finish_time)

```

## Overall Summary Plots

### Weather Summary
Out of all the entries, what's the weather like?

```{r}
# Weather bar plot
weather_counts <- jra_results_eng |> 
    group_by(weather) |> 
    summarise(count = n())

ggplot(data = weather_counts, aes(x = count, y = fct_reorder(weather, count))) +
    labs(x = "Amount of Days", y = "Weather") +
    geom_col()
```

Most of race days are sunny, followed by cloudy, then rainy/light rain. A pie chart may be appropriate given not that many categories.

```{r}
# Weather pie chart
ggplot(weather_counts, aes(x = "", y = count, fill = weather)) +
    geom_bar(stat = 'identity') +
    coord_polar("y", start = 0) +
    theme_void()
```

### Sex Summary
What's the distribution of horse gender?

```{r}
# Gender compostion
jra_results_eng |> 
    group_by(horse_sex) |> 
    summarise(sexcount = n()) |> 
    ggplot(aes(horse_sex, sexcount)) +
    geom_bar(stat = 'identity')
```

### Age Summary
What's the distribution of the horse's ages?

```{r}
# Horse age histogram
# jra_results_eng |> 
#     ggplot(aes(x = horse_age, y = after_stat(density))) +
#     geom_histogram(binwidth = 1) +
#     scale_x_continuous(breaks = seq(0, 16, by = 1))
```

Since horse age is discrete, numerical variable, it may make more sense to plot this as a lollipop chart. Also, there are a lot of observations in this dataset so having percentage instead of count on the y-axis will be easier on the eyes.

```{r}
# Horse age lollipop
jra_results_eng |> 
    group_by(horse_age) |> 
    summarise(age_count = n()) |> 

    ggplot() +
    geom_point(aes(x = horse_age, y = age_count / sum(age_count) * 100)) +
    geom_linerange(aes(x = horse_age, ymin = 0, ymax = age_count / sum(age_count) * 100)) +

    labs(x = "Horse Age", y = "Percentage (%)") +

    scale_x_continuous(breaks = seq(0, 16, by = 1)) +
    scale_y_continuous(breaks = seq(0, 30, by = 5), labels = scales::label_percent(scale = 1)) +
    theme_minimal()
```

## Specific Descriptive Plots

### Track condition & performance
How much does track condition for different distances affect winning times?

```{r}
# Create translations for conditions
conditions_translations <- tibble(
    track_condition1 = c("良", "稍重", "重", "不良"),
    track_condition1_eng = c("Firm", "Slightly Firm", "Soft", "Heavy"),

) |> mutate(track_condition1_eng = factor(track_condition1_eng, levels = c("Firm", "Slightly Firm", "Soft", "Heavy")))

# Create translations for selected racecourses
course_translations <- tibble(
    racecourse_name = c("中京", "東京", "京都", "阪神"),
    racecourse_name_eng = c("Chukyo", "Tokyo", "Kyoto", "Hanshin")
)

# Join translations to english df
jra_results_eng <- jra_results_eng |> 
    left_join(conditions_translations, by = "track_condition1") |> 
    left_join(course_translations, by = "racecourse_name")
```

```{r}
# Filter & aggregate to find winnings times at different racecourses & distances
course_conditions <- jra_results_eng |> 
    filter(final_position == 1, 
    racecourse_name_eng %in% course_translations$racecourse_name_eng) |> 
    group_by(racecourse_name_eng, distance_m, track_condition1_eng) |> 
    summarise(fastest_time = min(finish_time, na.rm = TRUE), races = n()) |> 
    ungroup() 
```

```{r}
# Filter to select distances
filtered_conditions_all <- course_conditions |> 
    filter(distance_m %in% c(1200, 1600, 1800, 2000))

ggplot(filtered_conditions_all, aes(x = track_condition1_eng, y = fastest_time)) +
    geom_point() +
    facet_grid(racecourse_name_eng ~ distance_m)
```

This plot can be improved, too much info. Try to find the differences between best condition and worst condition.

```{r}
# Filter conditions df to select conditions and calculate the difference
course_conditions_diff <- course_conditions |> 
    filter(track_condition1_eng %in% c("Firm", "Heavy")) 

# Filter to select distances
filtered_conditions_diff <- course_conditions_diff |> 
    filter(distance_m %in% c(1200, 1400, 1600, 1800, 2000))

ggplot(filtered_conditions_diff, aes(factor(distance_m), y = fastest_time, fill = track_condition1_eng)) +
    geom_col(position = 'dodge') +
    facet_wrap(~racecourse_name_eng) +

    labs(x = "Distance (m)", y = "Fastest Win Time (seconds)", title = "1st Place Time Differences", fill = "Track Condition") +

    scale_fill_manual(values= c("#8ac926", "#ff595e")) +

    theme_minimal()
```

### Successful Horses by Prize Money & Total Wins

```{r}
# Total horse winnings
winnings_df <- jra_results_eng |> 
    group_by(horse_name) |> 
    summarise(total_winnings = sum(prize_money_10kY, na.rm = TRUE), 
    avg_winnings_per_race = mean(prize_money_10kY, na.rm = TRUE),
    n_races = n()) |> 

    arrange(desc(total_winnings))

wincount_df <- jra_results_eng |> 
    group_by(horse_name) |> 
    summarise(total_wins = sum(final_position == 1, na.rm = TRUE),
    win_rate = sum(total_wins) / n(),
    n_races = n()) |> 
    arrange(desc(total_wins))

```

Some horses seem to have duplicates. For example, there are two horses called Eishin Fairy in this data, one who raced in 1986-1989 and one who raced in 2008-2012. I doubt a horse had a hiatus after racing for 3 years in the '80s and then came back at 19 years old and started to race again in 2008. 

```{r}
# Investigate duplicate horses
# eishin flash, confirmed duplicate
eishin_fairy <- jra_results_eng |> 
    filter(horse_name == "エイシンフェアリー")

# hakusan tsubame, just a horse who entered a bunch of races
hakusan_tsubame <- jra_results_eng |> 
    filter(horse_name == "ハクサンツバメ")

# cinderlla boy, seems to have three total
cinderella_boy <- jra_results_eng |> 
    filter(horse_name == "シンデレラボーイ")
```

This will likely affect aggregations that group by horse name. To mitigate this, I will filter to certain (famous) horses and confirm no duplicate horses so this shouldn't affect much but I'll keep it in mind.

### Horse Weight vs Performace

```{r}
# Weight effects on performace (top2 placement)
weight_effects <- jra_results_eng |> 
    mutate(placed_top2 = ifelse(final_position %in% c(1, 2), 1, 0)) |> 
    group_by(horse_weight) |> 
    summarise(perc_top2 = mean(placed_top2, na.rm = TRUE), n_races = n())

ggplot(data = weight_effects, aes(horse_weight, perc_top2)) +
    geom_point()

```

In this horse weight vs top 2 percentage plot, 'outlier' horses seem to have "skewed" win percentages due to a small sample size perhaps? 

### Horse Age vs Performance

```{r}
# Age effects on performance (top2 placement)
jra_results_eng |> 
    mutate(placed_top2 = ifelse(final_position %in% c(1, 2), 1, 0)) |> 
    group_by(horse_age) |> 
    summarise(perc_top2 = mean(placed_top2, na.rm = TRUE)) |> 
    ggplot(aes(horse_age, perc_top2)) +
    geom_point()
```

In this horse age vs top 2 percentage, it could be suffering from the same bias as the above. 

### Race Distance Specialization

```{r}
# include: true
# See distance distribution
ggplot(jra_results_eng, aes(x = distance_m)) +
    geom_histogram(binwidth = 100) +
    scale_x_continuous(breaks = seq(min(jra_results_eng$distance_m), max(jra_results_eng$distance_m), by = 200)) +
    theme_minimal() +
    labs(x = "Distance (m)", y = "Count", title = "Race Distance Histogram", subtitle = "Most race distances fall between 1200-2000m.") +
    scale_y_continuous(labels = label_comma(scale = 1))

# Add distance category
jra_results_eng  <- jra_results_eng |> 
    mutate(distance_category = case_when(
        distance_m <= 1400 ~ "sprint",
        distance_m > 1400 & distance_m <= 2000 ~ "medium",
        distance_m > 2000 ~ "long"
    ))
```

```{r}
# Select horses & translate
horse_translations <- tibble(
  horse_name = c("トウカイテイオー", "オグリキャップ", "ナリタブライアン", 
                 "タイキシャトル", "テイエムオペラオー", "ウオッカ", 
                 "エルコンドルパサー", "ロードカナロア", "キタサンブラック"),
  horse_name_eng = c("Tokai Teio", "Oguri Cap", "Narita Brian", 
                     "Taiki Shuttle", "T.M. Opera O", "Vodka", 
                     "El Condor Pasa", "Lord Kanaloa", "Kitasan Black")
)

# Left join on english dataframe
jra_results_eng <- left_join(jra_results_eng, horse_translations, by = "horse_name")

# Distance specialization
distance_specialize <- jra_results_eng |> 
    mutate(won = ifelse(final_position == 1, yes = 1, no = 0)) |> 
    group_by(horse_name_eng, distance_category) |> 
    summarise(wins = sum(won, na.rm = TRUE), races = n(), .groups = 'drop') |> 

    mutate(win_rate = wins / races) |> 
    arrange(desc(win_rate)) |> 
    filter(horse_name_eng %in% horse_translations$horse_name_eng) 
```

```{r}
#| include: true

# Distance wins proportion chart
ggplot(distance_specialize, aes(x = wins, y = horse_name_eng, fill = distance_category)) +
    geom_col(position = 'fill') +
    geom_text(aes(label = wins), position = position_fill(vjust = 0.5)) +
    scale_x_continuous(labels = label_percent()) +

    labs(title = "Distance Specialization", subtitle = "Horses specialize in distance categories throughout their career.", x = "Win Percentage", y = "Horse Name", fill = "Category") +
    
    scale_fill_manual(values = c("#1982c4", "#8ac926", "#ff595e")) +
    theme_minimal()
```

### Change in Win Times over Time

```{r}
# Different distances, average first place finish time over time
times_2000 <- jra_results_eng |> 
    filter(distance_m == 2000, final_position == 1) |> 
    group_by(year) |> 
    summarise(mean_2000m_win_time_sec = mean(finish_time, na.rm = TRUE))
```

```{r}
ggplot(times_2000, aes(x = year, y = mean_2000m_win_time_sec)) +
    geom_point()
```

```{r}
# Build map function for different race distances
distances_win_times <- map_dfr(set_names(c(1200, 1600, 1800, 2000)), ~{
    jra_results_eng |> 
        filter(distance_m == .x, final_position == 1, turf_dirt == "芝") |> 
        group_by(year) |> 
        summarise(mean_win_time_sec = mean(finish_time, na.rm = TRUE))
}, .id = "distance_m")

ggplot(distances_win_times, aes(year, mean_win_time_sec)) +
    geom_point() +
    facet_wrap(~distance_m, scales = "free_y") +

    labs(x = "Year", y = "Win Time (seconds)", title = "Trend in Average Win Times by Race Distance") +

    theme_minimal()
```

I like this plot because it shows average win times are getting faster, however I made the y scales to not start at zero which is kind-of a nono. When they do start at zero, the line is flat-looking with just a slightly negative trend because of the ever-so-slightly faster times throughout the years. Debating this one.

### Running Strategies

```{r}
# Pivot to long for this step
jra_results_long <- jra_results_eng |> 
    pivot_longer(cols = c(corner1_position:corner4_position, final_position),
    names_to = "corner_number", names_pattern = "(.*)_position",
    values_to = "position")
```

```{r}
# Write function to create subplot
create_horse_subplot <- function(data_long, race_name_input = "有馬記念", year_input, horse_name_input, plot_title_input, highlight_label){
    data_long |> 
        filter(race_name == race_name_input & year == year_input) |> 
        ggplot(aes(x = corner_number, y = factor(position), group = horse_name, color = horse_name)) +
        geom_line(linewidth = 1.5) +

        labs(y = "Race Position", title = plot_title_input) +

        # Reverse y-axis for more intuitive plot
        scale_y_discrete(limits = rev) +

        # Finish line
        geom_vline(aes(xintercept = "final"), color = "black", linewidth = 1.2, linetype = "dashed") +

        #geom_label(aes(x = "final", y = 2), label = "Finish") +
        theme_minimal() +

        # Highlight winner
        gghighlight(horse_name == horse_name_input, 
        label_params = list(
            nudge_x = -1.5, nudge_y = -5, label = highlight_label
        ), 
        use_group_by = FALSE) +
        
        theme(axis.title.x = element_blank())
}
```

```{r fig.height=10}
plot_front <- create_horse_subplot(jra_results_long, year_input = 2017, horse_name_input = "キタサンブラック", plot_title_input = "Strategy: Front", highlight_label = "Kitasan Black")

plot_pace <- create_horse_subplot(jra_results_long, year_input = 1993, horse_name_input = "トウカイテイオー", plot_title_input = "Strategy: Late", highlight_label = "Tokai Teio")

plot_end <- create_horse_subplot(jra_results_long, year_input = 2012, horse_name_input = "ゴールドシップ", plot_title_input = "Strategy: End", highlight_label = "Goldship")

plot_front / plot_pace / plot_end
```

In addition to distance specialties, it's common for certain horses to also have preferred running strategies. Front-runners grab the lead early and defend it throughout the race. Pace chasers sit behind the crowd, read the situation, and battle for first at the last stretch. While end closers, hang towards the back, save their energy and give it their all towards the last corners.

### Favorite Winrates

The Arima Kinen (有馬記念) is one of two "All-Star" races throughout the year and is considered one of the world's most popular horserace. Additionally, this race also allows for racing fans themselves to select the horses which enter and run, based on popular vote.

```{r}
# All Arima Kinen
all_arima_kinen <- jra_results_eng |> 
    filter(race_name == "有馬記念") 
```

```{r}
# Find 1st, 2nd, 3rd favorite win rates
all_arima_kinen |> 
    filter(popular_rank %in% 1:3) |> 
    group_by(popular_rank) |> 
    summarise(win_rate = mean(final_position == 1, na.rm = TRUE))
```

According to the above calculation, at the annual Arima Kinen:

- The number one favorite has won 41.2% of the time.

- The number two favorite, 14.3%.

- The number three favorite, 5.88%.

Can write a function / map to extend this to other G1 races?

```{r}
# Create function to feed into map
find_winrates <- function(data, race){
    # Filter to race
    race_only <- data |> 
        filter(race_name == race)

    # Various favorite's winrates
    map_dfr(1:3, ~{
        race_only |> 
            filter(popular_rank == .x) |> 
            summarise(win_rate = mean(final_position == 1, na.rm = TRUE), race_name = race)
    }, .id = 'popular_rank') 
}

# find_winrates(jra_results_eng, race = "有馬記念")
```

```{r}
# Call function on race list
race_list <- c("天皇賞(春)", "天皇賞(秋)", "有馬記念", "ジャパンカップ", "宝塚記念", "東京優駿")
winrate_df <- map_dfr(race_list, ~{
    find_winrates(jra_results_eng, race = .x)
})
```

```{r fig.height=7, fig.width=10}
#| include: true
ggplot(winrate_df, aes(race_name, win_rate, fill = popular_rank)) +
    geom_col(position = 'dodge') +
    scale_x_discrete(labels = c("Japan Cup", "Tenno Sho (Spring)", "Tenno Sho (Autumn)", "Takarazuka Kinen", "Arima Kinen", "Tokyo Yushun")) +
    
    labs(x = "Race Name", y = "Win Rate", fill = "Favorite-to-Win") +

    scale_fill_manual(values = c("#1982c4", "#8ac926", "#ff595e")) +

    scale_y_continuous(labels = label_percent()) +

    theme_minimal()
```

### Prize Money Scale

```{r}
prize_money <- jra_results_eng |> 
    filter(listed_graded_race %in% c("G1", "G2", "G3"), final_position == 1, year != 2021) |> 
    group_by(year, listed_graded_race) |> 
    summarise(mean_prize_10kY = mean(prize_money_10kY, na.rm = TRUE),
    max_prize_10kY = max(prize_money_10kY, na.rm = TRUE),
    min_prize_10kY = min(prize_money_10kY, na.rm = TRUE)) |> 
    ungroup() |> 
    
    mutate(date = as_date(paste(year, "01", "01", sep = "-")))

ggplot(prize_money, aes(year, max_prize_10kY, group = listed_graded_race, color = listed_graded_race)) +
    geom_line() +
    # geom_ribbon(aes(ymax = max_prize_10kY, ymin = min_prize_10kY), alpha = 0.5) +

    labs(x = "Year", y = "Maximum Prize (thousands of ¥)", title = "Maximum 1st Prize Over Time", color = "Race Grade") +

    annotate(geom = 'curve', x = 2018, xend = 2020, y = 26000, yend = 30000, arrow = arrow()) +
    annotate(geom = 'label', x = 2018, y = 25000, label = "~ $2M USD!") +


    scale_x_continuous(breaks = seq(1985, 2020, by = 5)) +
    
    scale_y_continuous(labels = label_comma(scale = 10)) +

    theme_classic()
```

### Inner Post Track Bias

```{r}
# Filter to winners, aggregate by post number and calculate total wins
post_wins <- jra_results_eng |> 
    filter(final_position == 1) |> 
    group_by(horse_number) |> 
    summarise(total_wins = n())

ggplot(post_wins, aes(x = factor(horse_number), y = total_wins)) +
    geom_point() +

    labs(x = "Horse Number", y = "Total Wins", title = "Start Position vs Total Wins", subtitle = "Horses on the inside post have a higher amount of wins.", caption = "Increase in horse number correlates to outer starting position") +

    theme_minimal()
```

The start position does seem to have an effect on wins. Start positions 1-6 have high wins and has the number increases (outer start position), wins go down. This relationship would only be significant if starting position is assigned at random, not by any other factors.

# EDA Questions

1. What have you learned about your data? Have any potentially interesting patterns emerged? Point to specific visualizations that you created as you describe your findings.

- So far, I've learned that this horse data is very comprehensive and complex. Early in the exploration I learned about duplicate horses, horses that are named the same name but are completely different horses. Then I learned how horses who run few races but win, can skew win percentages, especially when looking at outlier weights & ages. I'm finding the need to standardize/normalize some things. For example, my horse age distribution and horse age win percentage. In the age distribution, most horses are 3-5 years old, in the win percentage by horse age, there's also a high amount of horses in that age range placing top 3. It's quite possible that because there are a lot of horses in this age range, there will be more wins in this age range. As far as interesting patterns, I think the win times over time are cool, showing that horses are "getting faster" and that records for certain distances are consistently being set.

2. In FPM #1, you outlined some questions that you wanted to answer using these data. Have you made any strides towards answering those questions? If yes, how so? If no, what next steps do you need to take (e.g. I need to create X plot type, I still need to track down Y data, I need to restructure existing data so that you can visualize it in Z ways, etc.)? Have any new questions emerged?

My first question was about what summary statistics can be extracted and for the most part I answered this with weather, age, and gender composition of our data. Another question I was interested in was if there was any attribute that would give horses an advantage to win over another. I looked at weight and age but they don't seem to be good predictors and the amount of races entered by each horse aren't all the same. This was pretty expected as I don't think weight nor age would give a competitive edge. Additionally, I wanted to investigate track bias in horse racing, where horses on the inside 'run less' than horses on the outside due to the circular track. Even though horses can move left and right after the start, there still seems to be some type of track bias. Though, I did this graph hastily so maybe the aggregation is incorrect in some way but to be investigated further!

3. What challenges do you foresee encountering with your data? These can be data wrangling and / or visualization challenges.

Some challenges have been pointed out earlier. While I translated the Japanese columns, the data values themselves are still in Japanese and these don't show up in a rendered quarto doc. I think that's one of the biggest issues as I have to manually translate the values but I think the method I'll stick with is: 1. Filter, aggregate, etc., 2. Create translation dataframe, 3. Plot with English values. One last challenge is aggregation bias. There's a lot of variation between races, so evaluating things like performance can be affected by this variation. 